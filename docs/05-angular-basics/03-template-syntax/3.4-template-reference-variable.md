# Template Reference and `ViewChild`

Think of **Template Reference Variables** as "ID tags" for your HTML elements, and **ViewChild/Children** as the "grabber" that pulls those elements into your TypeScript code.

---

### 1. Template Reference Variables (`#var`)

These allow you to reference a DOM element or an Angular component directly within your HTML template.

* **Syntax:** Use the `#` symbol followed by a name.
* **Scope:** Only available within that specific template.

```html
<input #nameInput type="text" placeholder="Enter name">

<button (click)="logValue(nameInput.value)">Log Value</button>

```

---

### 2. ViewChild (Single Element)

When you need to access that `#nameInput` inside your **TypeScript** file, you use `@ViewChild`.

#### The "Classic" Decorator Approach

Before Angular 17.2, we used the `@ViewChild` decorator.

```typescript
import { Component, ViewChild, ElementRef } from '@angular/core';

@Component({ ... })
export class MyComponent {
  // Grab the element with #nameInput
  @ViewChild('nameInput') inputField!: ElementRef<HTMLInputElement>;

  focusInput() {
    this.inputField.nativeElement.focus();
  }
}

```

#### The Modern "Signal" Approach (Angular 17.2+)

Angular is moving toward **Signals** for better reactivity. The new `viewChild` function is cleaner and provides better type safety.

```typescript
import { Component, viewChild, ElementRef } from '@angular/core';

export class MyComponent {
  // This is now a Signal!
  inputField = viewChild<ElementRef<HTMLInputElement>>('nameInput');

  focusInput() {
    // Access using the signal getter ()
    this.inputField()?.nativeElement.focus();
  }
}

```

---

### 3. ViewChildren (Multiple Elements)

Use this when you have a list of elements (usually generated by a loop) and you want to grab all of them at once.


### Where to Place the Variable

In both the old and modern approaches, you attach `#listItem` to the tag that is being generated multiple times.

#### Modern `@for` Approach

```html
<ul>
  @for (user of users; track user.id) {
    <li #listItem>
      {{ user.name }}
    </li>
  }
</ul>

```

#### Old `*ngFor` Approach

```html
<ul>
  <li *ngFor="let user of users" #listItem>
    {{ user.name }}
  </li>
</ul>

```

---

### How Angular Sees the Data

When you use `viewChildren('listItem')` in your TypeScript, Angular searches the template for **every** instance of that `#listItem` tag and bundles them into a list.



#### The "Classic" Decorator Approach

This returns a `QueryList`, which acts like an array but stays updated if the DOM changes.

```typescript
@ViewChildren('listItem') items!: QueryList<ElementRef>;

logAll() {
  this.items.forEach(item => console.log(item.nativeElement.innerText));
}

```

#### The Modern "Signal" Approach

This returns a **Signal** containing an array. It automatically updates when the list changes.

```typescript
// No more QueryList; it's just a Signal of an array
items = viewChildren<ElementRef>('listItem');

logAll() {
  this.items().forEach(item => console.log(item.nativeElement.innerText));
}

```

---

### Key Comparison: Decorators vs. Signals

| Feature | `@ViewChild` (Decorator) | `viewChild()` (Signal) |
| --- | --- | --- |
| **Timing** | Only available after `ngAfterViewInit`. | Available when the signal is computed. |
| **Type Safety** | Requires manual typing (`!`). | Naturally typed and more predictable. |
| **Reactivity** | Harder to track changes. | Built into Angular's new reactive engine. |

---

### A Quick Note on `static: true`

In the old decorator approach, you might see `@ViewChild('var', { static: true })`.

* **`static: true`**: The element is available early (in `ngOnInit`). Only works if the element isn't inside an `*ngIf` or `*ngFor`.
* **The Signal approach** handles this much more gracefully without needing that confusing configuration.


---

### Practical Example: Accessing the Items

Here is how you would actually "grab" those items in your TypeScript using the modern Signal-based approach:

```typescript
import { Component, viewChildren, ElementRef, AfterViewInit, effect } from '@angular/core';

@Component({ ... })
export class UserListComponent {
  // This grabs all elements marked with #listItem
  listElements = viewChildren<ElementRef>('listItem');

  constructor() {
    // Signals make it easy to react when the list changes!
    effect(() => {
      console.log('Number of items in DOM:', this.listElements().length);
    });
  }

  highlightAll() {
    // You can iterate over the signal's array
    this.listElements().forEach(el => {
      el.nativeElement.style.backgroundColor = 'yellow';
    });
  }
}

```

### Important Note on Timing

One of the biggest "gotchas" with `viewChildren` is that the list is **empty** when the component first starts (`ngOnInit`). This is because the HTML hasn't been rendered yet.

* **Decorators:** You must wait for the `ngAfterViewInit` lifecycle hook.
* **Signals:** You can use an `effect()` (as shown above) or simply access it inside a function that runs after the page has loaded.


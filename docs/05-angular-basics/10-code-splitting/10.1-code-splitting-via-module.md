# Code Splitting Via Module

## Project Metadata

- Angular CLI: 21.x
- Styling: Tailwind CSS
- Repository: [https://github.com/neutral-00/practice-angular](https://github.com/neutral-00/practice-angular)
- Parent branch: `main`
- Working branch: `10.1-code-splitting-via-module`

---

## Learning Objective

- Understand how Angular performs **code splitting** using **lazy-loaded feature modules**
- Learn the correct routing structure between **AppRoutingModule** and **feature routing modules**

---

## Scenario Overview

We will:

1. Generate a new **AdminModule** with its own routing
2. Create a simple `AdminDashboardComponent`
3. Configure **child routing** inside the admin module
4. Lazy-load the admin module from the root router
5. Verify how `/admin` is resolved at runtime

---

## Step 1: Generate Admin Module with Routing

```bash
ng g module admin --routing --type=module
```

This creates:

```
admin/
 ├── admin.module.ts
 └── admin-routing.module.ts
```

> ⚠️ `--routing` is important — lazy-loaded modules must define their own routes.

---

## Step 2: Create Admin Dashboard Component

```bash
ng g c admin/admin-dashboard --type=component
```

Result:

```
admin/
 ├── admin-dashboard/
 │   ├── admin-dashboard.component.ts
 │   ├── admin-dashboard.component.html
 │   └── admin-dashboard.component.css
```

---

## Step 3: Configure Admin Module Routing

### `admin-routing.module.ts`

```ts
import { NgModule } from "@angular/core";
import { RouterModule, Routes } from "@angular/router";
import { AdminDashboardComponent } from "./admin-dashboard/admin-dashboard.component";

const routes: Routes = [
  {
    path: "",
    component: AdminDashboardComponent,
  },
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class AdminRoutingModule {}
```

### Why `path: ''`?

- The empty path represents the **default route of the lazy-loaded module**
- When `/admin` is activated, Angular looks inside this module
- `''` matches immediately and loads `AdminDashboardComponent`

➡️ Final URL:

```
/admin → AdminDashboardComponent
```

---

## Step 4: Verify Admin Module Declaration

### `admin.module.ts`

```ts
import { NgModule } from "@angular/core";
import { CommonModule } from "@angular/common";
import { AdminRoutingModule } from "./admin-routing.module";
import { AdminDashboardComponent } from "./admin-dashboard/admin-dashboard.component";

@NgModule({
  declarations: [AdminDashboardComponent],
  imports: [CommonModule, AdminRoutingModule],
})
export class AdminModule {}
```

---

## Step 5: Lazy Load Admin Module from App Routing

### `app-routing.module.ts`

```ts
import { NgModule } from "@angular/core";
import { RouterModule, Routes } from "@angular/router";

const routes: Routes = [
  {
    path: "admin",
    loadChildren: () =>
      import("./admin/admin.module").then((m) => m.AdminModule),
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

### Important Notes

- ❌ Do NOT import `AdminModule` directly in `AppModule`
- ❌ Do NOT reference `AdminDashboardComponent` in root routes
- ✅ Use `loadChildren` only

This ensures the module is **excluded from the initial bundle**.

---

## Step 6: Runtime Behavior (How Code Splitting Happens)

1. App loads → main bundle only
2. User navigates to `/admin`
3. Angular downloads `admin.module.js` (separate chunk)
4. Admin routes are registered
5. `AdminDashboardComponent` is rendered

---

## Common Mistakes

❌ Eager loading the module:

```ts
import { AdminModule } from "./admin/admin.module";
```

❌ Using component directly in app routes:

```ts
{ path: 'admin', component: AdminDashboardComponent }
```

Both **break code splitting**.

---

## Summary

- Code splitting via module is achieved using `loadChildren`
- Feature modules must define routes using `RouterModule.forChild()`
- Each lazy-loaded module becomes a **separate JS bundle**

---

## Next

➡️ Continue with **10.2 – Code Splitting in Standalone Components**

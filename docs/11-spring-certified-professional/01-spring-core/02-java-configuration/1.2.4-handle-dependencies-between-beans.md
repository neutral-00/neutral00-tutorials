# 1.2.4 Handle Dependencies between Beans

### Project Metadata

- Repository: [https://github.com/neutral-00/poc-springboot](https://github.com/neutral-00/poc-springboot)
- **Parent Branch:** `1.2.3-handle-multiple-configuration-files`
- **Branch:** `1.2.4-handle-dependencies-between-beans`

### Learning Objectives

- [ ] Handle Dependencies between Beans (method parameters, `@DependsOn`)

**Scenario:** Create a **NotificationRouter** that depends on **all 3 notification services** (Email, SMS, Slack). Demonstrate **2 ways** Spring resolves bean dependencies.

## Step 1: Notification Router (Depends on All Services)

```java
// com.lousing.poc.service.NotificationRouter.java (NEW)
package com.lousing.poc.service;

import java.util.List;

public class NotificationRouter {
    private final List<NotificationService> notificationServices;

    public NotificationRouter(List<NotificationService> notificationServices) {
        this.notificationServices = notificationServices;
    }

    public void routeCriticalAlert(String message, String recipient) {
        System.out.println("\nüîÑ Routing critical alert to all channels:");
        notificationServices.forEach(service -> service.send(message, recipient));
    }

    public void sendViaEmailOnly(String message, String recipient) {
        notificationServices.stream()
            .filter(service -> service instanceof EmailNotificationService)
            .forEach(service -> service.send(message, recipient));
    }
}
```

## Step 2: Updated Master Configuration (Method Parameter Injection)

```java
// com.lousing.poc.config.NotificationMasterConfig.java (UPDATED)
package com.lousing.poc.config;

import com.lousing.poc.service.NotificationRouter;
import com.lousing.poc.service.NotificationService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.DependsOn;

@Configuration
@Import({EmailConfig.class, SmsConfig.class, SlackConfig.class})
public class NotificationMasterConfig {

    // ‚úÖ WAY 1: Method parameter injection (Spring auto-wires ALL NotificationService beans)
    @Bean
    public NotificationRouter notificationRouter(List<NotificationService> allNotificationServices) {
        return new NotificationRouter(allNotificationServices);
    }

    // ‚úÖ WAY 2: Explicit dependency injection (shows order control)
    @Bean
    @DependsOn({"emailNotificationService", "smsNotificationService", "slackNotificationService"})
    public NotificationRouter orderedNotificationRouter(
            NotificationService emailNotificationService,
            NotificationService smsNotificationService,
            NotificationService slackNotificationService) {
        return new NotificationRouter(List.of(
            emailNotificationService, smsNotificationService, slackNotificationService
        ));
    }
}
```

## Step 3: Dependency Demo Runner

```java
// com.lousing.poc.DependencyDemoRunner.java (NEW - Replaces MultiConfigDemoRunner)
package com.lousing.poc;

import com.lousing.poc.service.NotificationRouter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class DependencyDemoRunner implements CommandLineRunner {

    private final ApplicationContext context;
    private final NotificationRouter router1;  // List injection
    private final NotificationRouter router2;  // Explicit injection

    public DependencyDemoRunner(
            ApplicationContext context,
            @Qualifier("notificationRouter") NotificationRouter router1,
            @Qualifier("orderedNotificationRouter") NotificationRouter router2
    ) {
        this.context = context;
        this.router1 = router1;
        this.router2 = router2;
    }

    @Override
    public void run(String... args) {
        System.out.println("\nüöÄ === BEAN DEPENDENCIES ===");

        demoListInjection();
        demoExplicitDependencies();
        demoBeanCreationOrder();

        System.out.println("‚úÖ Dependency injection working!");
        System.out.println("----------------------------------");
    }

    private void demoListInjection() {
        System.out.println("\n1Ô∏è‚É£ List<NotificationService> injection:");
        router1.routeCriticalAlert("üö® Server Down - List injection", "ops@company.com");
    }

    private void demoExplicitDependencies() {
        System.out.println("\n2Ô∏è‚É£ Explicit parameter injection:");
        router2.sendViaEmailOnly("Only email - explicit deps", "dev@company.com");
    }

    private void demoBeanCreationOrder() {
        System.out.println("\n3Ô∏è‚É£ @DependsOn order control:");
        System.out.println("NotificationRouter created AFTER all 3 services ‚úÖ");
    }
}
```

## Step 4: Bean Dependency Resolution Flow

```
Spring Container Boot Sequence:
1. EmailConfig.emailNotificationService() ‚Üí Creates Email bean
2. SmsConfig.smsNotificationService()   ‚Üí Creates SMS bean
3. SlackConfig.slackNotificationService() ‚Üí Creates Slack bean
4. NotificationMasterConfig.notificationRouter(List)
   ‚îú‚îÄ‚îÄ Spring collects ALL NotificationService beans ‚Üí [Email,SMS,Slack]
   ‚îî‚îÄ‚îÄ Creates NotificationRouter ‚úÖ
5. @DependsOn ensures notificationRouter2 created LAST
```

## Expected Output

```bash
mvn spring-boot:run
```

```
‚úÖ Multiple Config Files Loaded!
----------------------------------

üöÄ === BEAN DEPENDENCIES ===
1Ô∏è‚É£ List<NotificationService> injection:
üîÑ Routing critical alert to all channels:
üìß Email to ops@company.com: üö® Server Down - List injection
üì± SMS to ops@company.com: üö® Server Down - List injection
üí¨ Slack to #ops@company.com: üö® Server Down - List injection

2Ô∏è‚É£ Explicit parameter injection:
üìß Email to dev@company.com: Only email - explicit deps

3Ô∏è‚É£ @DependsOn order control:
NotificationRouter created AFTER all 3 services ‚úÖ

‚úÖ Dependency injection working!
----------------------------------
```

## 2 Ways Spring Handles Bean Dependencies

| Method              | Code                                                 | When Spring Injects                  |
| ------------------- | ---------------------------------------------------- | ------------------------------------ |
| **List Injection**  | `List<NotificationService> services`                 | **Auto-collects ALL** matching beans |
| **Explicit Params** | `NotificationService email, NotificationService sms` | **Exact bean name matching**         |
| **@DependsOn**      | `@DependsOn("bean1", "bean2")`                       | **Creation order control**           |

## Key Learning Points

```
‚úÖ List<Interface> = Spring collects ALL implementations automatically
‚úÖ Method params = Spring matches by bean name or type
‚úÖ @DependsOn = Explicit creation order (rarely needed)
‚úÖ Spring resolves ALL dependencies BEFORE creating dependent bean
```

## File Structure (Branch 1.2.4)

```
1.2.4-handle-dependencies-between-beans/  (inherits from 1.2.3)
‚îú‚îÄ‚îÄ src/main/java/com/lousing/poc/
‚îÇ   ‚îú‚îÄ‚îÄ DependencyDemoRunner.java         # NEW - Tests dependencies
‚îÇ   ‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ NotificationRouter.java       # NEW - Depends on all services
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îî‚îÄ‚îÄ NotificationMasterConfig.java # UPDATED - Dependency injection
```

## Verification Checklist

**‚úÖ Complete when:**

- [ ] `NotificationRouter` receives **all 3 services** via `List`
- [ ] **2 routers** created (List injection + explicit params)
- [ ] `mvn spring-boot:run` shows **Email + SMS + Slack** output
- [ ] `@DependsOn` demonstrates order control
- [ ] **No circular dependencies** (Spring would fail)

**Next: `1.2.5-explain-and-define-bean-scopes.md`** - Singleton vs Prototype scopes!

**üéØ Success:** Complex bean dependencies resolved via Java config! üöÄ

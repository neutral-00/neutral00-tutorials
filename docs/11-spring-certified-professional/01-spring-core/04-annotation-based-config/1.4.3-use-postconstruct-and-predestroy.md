# 1.4.3 Use @PostConstruct and @PreDestroy

### Project Metadata

- Repository: [https://github.com/neutral-00/poc-springboot](https://github.com/neutral-00/poc-springboot)
- **Parent Branch:** `main`
- **Branch:** `1.4.3-use-postconstruct-and-predestroy`

---

## üéØ Learning Objectives

- [ ] Understand what `@PostConstruct` and `@PreDestroy` do
- [ ] Add lifecycle callbacks to Spring-managed beans
- [ ] Observe initialization and destruction behavior in a running Spring Boot application
- [ ] Understand when to use these annotations and when not to

---

## **Scenario**

Your team wants certain beans to perform setup work after dependency injection is complete (e.g., loading caches, validating configuration) and cleanup work before the application shuts down (e.g., closing connections, flushing buffers).

Spring provides two lifecycle annotations:

- `@PostConstruct` ‚Üí runs **after** the bean is created and dependencies are injected
- `@PreDestroy` ‚Üí runs **before** the bean is destroyed

You will create a bean that logs initialization and cleanup steps so the team can clearly see how these lifecycle hooks behave.

---

# ‚úÖ Step-by-Step Tutorial

---

## **Step 1: Create a new branch**

```bash
git checkout main
git pull
git checkout -b 1.4.3-use-postconstruct-and-predestroy
```

---

## **Step 2: Create a bean that uses @PostConstruct and @PreDestroy**

Create:

```
com.lousing.poc.services.LifecycleService
```

```java
package com.lousing.poc.services;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.springframework.stereotype.Component;

@Component
public class LifecycleService {
    public LifecycleService() {
        System.out.println("\n‚û°Ô∏è LifecycleService: Constructor called");
    }

    @PostConstruct
    public void init() {
        System.out.println("‚úÖ LifecycleService: @PostConstruct initialization logic executed\n");
    }

    @PreDestroy
    public void cleanup() {
        System.out.println("üßπ LifecycleService: @PreDestroy cleanup logic executed");
    }
}
```

### ‚úÖ What‚Äôs happening here?

- The constructor runs **first** when the bean is created.
- `@PostConstruct` runs **after** Spring injects dependencies.
- `@PreDestroy` runs **when the application context is shutting down**.

---

## **Step 3: Trigger bean creation in the main application**

Modify your main class to retrieve the bean:

```java
@SpringBootApplication
public class PocSpringbootApplication {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(PocSpringbootApplication.class, args);

        System.out.println("\n‚úÖ Lifecycle Demo Ready!");

        // Force bean retrieval so logs appear immediately
        context.getBean(LifecycleService.class);

        System.out.println("----------------------------------");
    }
}
```

Spring would create the bean anyway, but retrieving it ensures the logs appear right after startup.

---

## **Step 4: Run the application**

```bash
mvn spring-boot:run
```

Expected output:

```
‚û°Ô∏è LifecycleService: Constructor called
‚úÖ LifecycleService: @PostConstruct initialization logic executed

‚úÖ Lifecycle Demo Ready!
----------------------------------
```

When you stop the application (Ctrl+C):

```
üßπ LifecycleService: @PreDestroy cleanup logic executed
```

---

## ‚úÖ Step 5: Understand when to use these annotations

### ‚úÖ Use `@PostConstruct` for:

- Loading configuration from a file
- Initializing caches
- Validating injected dependencies
- Starting scheduled tasks

### ‚úÖ Use `@PreDestroy` for:

- Closing database connections
- Stopping background threads
- Flushing logs or buffers
- Releasing external resources

---

## ‚úÖ Step 6: When NOT to use them

### ‚ùå Avoid in:

- Prototype-scoped beans (cleanup won‚Äôt run)
- Complex initialization logic (prefer `InitializingBean` or custom init methods)
- Beans managed outside Spring (annotations won‚Äôt work)

### ‚ùå Avoid heavy work in @PostConstruct

It slows down application startup.

---

## ‚úÖ Summary

In this tutorial, you learned:

- How `@PostConstruct` and `@PreDestroy` work
- How Spring manages bean lifecycle callbacks
- When to use these annotations
- When to avoid them
- How to observe initialization and cleanup behavior in a real Spring Boot app

This prepares you for the next topic: **stereotype annotations**, which build on component scanning and bean lifecycle concepts.

---

Ready for **1.4.4 Explain and use ‚ÄúStereotype‚Äù Annotations**?
